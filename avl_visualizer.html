<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AVL Tree Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 15px;
            overflow: hidden;
        }

        .container {
            max-width: 1400px;
            width: 100%;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 15px;
            flex-shrink: 0;
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 5px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 0.95em;
        }

        .controls {
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            margin-bottom: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .input-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        input[type="number"] {
            padding: 10px 15px;
            font-size: 15px;
            border: 2px solid #667eea;
            border-radius: 8px;
            width: 140px;
            transition: all 0.3s;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: #764ba2;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        button {
            padding: 10px 25px;
            font-size: 15px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            color: white;
        }

        .btn-insert {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .btn-clear {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .btn-random {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        button:active {
            transform: translateY(0);
        }

        .canvas-container {
            background: white;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            padding: 20px;
            overflow: hidden;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 0;
        }

        #treeCanvas {
            display: block;
            margin: 0 auto;
        }

        .info {
            background: rgba(255, 255, 255, 0.95);
            padding: 12px;
            border-radius: 10px;
            margin-top: 15px;
            text-align: center;
            color: #333;
            flex-shrink: 0;
        }

        #statusText {
            font-size: 14px;
            margin-bottom: 8px;
        }

        .legend {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
        }

        .legend-box {
            width: 18px;
            height: 18px;
            border-radius: 4px;
        }

        .legend-normal { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .legend-rotating { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
        .legend-new { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸŒ³ AVL Tree Visualizer</h1>
            <p>Watch the self-balancing binary search tree in action!</p>
        </div>

        <div class="controls">
            <div class="input-group">
                <input type="number" id="valueInput" placeholder="Enter value" min="1" max="999">
                <button class="btn-insert" onclick="insertValue()">Insert</button>
            </div>
            <button class="btn-random" onclick="insertRandom()">Insert Random</button>
            <button class="btn-clear" onclick="clearTree()">Clear Tree</button>
        </div>

        <div class="canvas-container">
            <canvas id="treeCanvas"></canvas>
        </div>

        <div class="info">
            <div id="statusText">Enter a value to start building your AVL tree</div>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-box legend-normal"></div>
                    <span>Normal Node</span>
                </div>
                <div class="legend-item">
                    <div class="legend-box legend-rotating"></div>
                    <span>Rotating Node</span>
                </div>
                <div class="legend-item">
                    <div class="legend-box legend-new"></div>
                    <span>Newly Inserted</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // AVL TREE LOGIC - Converted from your Java code
        // ============================================================================
        
        class AVLNode {
            constructor(data) {
                this.data = data;
                this.h = 1;
                this.left = null;
                this.right = null;
                // Visualization properties (don't remove these)
                this.x = 0;
                this.y = 0;
                this.targetX = 0;
                this.targetY = 0;
                this.state = 'normal'; // 'normal', 'rotating', 'new'
            }
        }

        class AVLTree {
            constructor() {
                this.root = null;
                this.animationQueue = []; // For tracking rotations
            }

            // Insert method - converted from your Java code
            insert(root, x) {
                if (root === null) {
                    const newNode = new AVLNode(x);
                    newNode.state = 'new';
                    this.animationQueue.push({ type: 'insert', node: newNode });
                    return newNode;
                }
                
                if (x < root.data) {
                    root.left = this.insert(root.left, x);
                } else {
                    root.right = this.insert(root.right, x);
                }

                this.updateHeight(root);

                if (this.getBF(root) === -2) { // Right Heavy - RR, RL
                    if (this.getBF(root.right) === -1) { // RR
                        root = this.leftRotate(root);
                    } else { // RL
                        root.right = this.rightRotate(root.right);
                        root = this.leftRotate(root);
                    }
                } else if (this.getBF(root) === +2) { // Left Heavy - LL, LR
                    if (this.getBF(root.left) === +1) { // LL
                        root = this.rightRotate(root);
                    } else { // LR
                        root.left = this.leftRotate(root.left);
                        root = this.rightRotate(root);
                    }
                }

                return root;
            }

            // Left Rotate - converted from your Java code
            leftRotate(root) {
                const newRoot = root.right;
                root.right = newRoot.left; // T2
                
                // Record rotation for animation
                this.animationQueue.push({ type: 'rotate', nodes: [root, newRoot], direction: 'left' });
                
                this.updateHeight(root);
                newRoot.left = root;
                this.updateHeight(newRoot);
                return newRoot;
            }

            // Right Rotate - matching your Java style
            rightRotate(root) {
                const newRoot = root.left;
                root.left = newRoot.right; // T2
                
                // Record rotation for animation
                this.animationQueue.push({ type: 'rotate', nodes: [root, newRoot], direction: 'right' });
                
                this.updateHeight(root);
                newRoot.right = root;
                this.updateHeight(newRoot);
                return newRoot;
            }

            // Update Height - converted from your Java code
            updateHeight(root) {
                if (root === null) return;
                root.h = 1 + Math.max(
                    root.left === null ? 0 : root.left.h,
                    root.right === null ? 0 : root.right.h
                );
            }

            // Get Balance Factor - converted from your Java code
            getBF(root) {
                if (root === null) return 0;
                return (root.left === null ? 0 : root.left.h) - 
                       (root.right === null ? 0 : root.right.h);
            }

            // Public method to insert value
            insertValue(value) {
                this.animationQueue = [];
                this.root = this.insert(this.root, value);
                return this.animationQueue;
            }

            // Helper method for visualization (returns height)
            getBalance(node) {
                return this.getBF(node);
            }
        }

        // ============================================================================
        // END OF AVL TREE LOGIC
        // ============================================================================


        // ============================================================================
        // VISUALIZATION CODE - DO NOT MODIFY (handles rendering and animation)
        // ============================================================================
        
        const canvas = document.getElementById('treeCanvas');
        const ctx = canvas.getContext('2d');
        const statusText = document.getElementById('statusText');

        // Make canvas responsive to container size
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth - 40;
            canvas.height = container.clientHeight - 40;
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        const tree = new AVLTree();
        let isAnimating = false;

        function calculatePositions(node, x, y, spacing) {
            if (!node) return;

            node.targetX = x;
            node.targetY = y;

            if (!node.x && !node.y) {
                node.x = x;
                node.y = y;
            }

            if (node.left) {
                calculatePositions(node.left, x - spacing, y + 80, spacing / 2);
            }
            if (node.right) {
                calculatePositions(node.right, x + spacing, y + 80, spacing / 2);
            }
        }

        function animateNode(node) {
            const speed = 0.15;
            const dx = node.targetX - node.x;
            const dy = node.targetY - node.y;

            node.x += dx * speed;
            node.y += dy * speed;

            return Math.abs(dx) < 0.5 && Math.abs(dy) < 0.5;
        }

        function drawTree(node) {
            if (!node) return;

            // Draw edges first
            if (node.left) {
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(node.x, node.y);
                ctx.lineTo(node.left.x, node.left.y);
                ctx.stroke();
                drawTree(node.left);
            }

            if (node.right) {
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(node.x, node.y);
                ctx.lineTo(node.right.x, node.right.y);
                ctx.stroke();
                drawTree(node.right);
            }

            // Draw node
            let gradient;
            if (node.state === 'rotating') {
                gradient = ctx.createLinearGradient(node.x - 25, node.y - 25, node.x + 25, node.y + 25);
                gradient.addColorStop(0, '#f093fb');
                gradient.addColorStop(1, '#f5576c');
            } else if (node.state === 'new') {
                gradient = ctx.createLinearGradient(node.x - 25, node.y - 25, node.x + 25, node.y + 25);
                gradient.addColorStop(0, '#4facfe');
                gradient.addColorStop(1, '#00f2fe');
            } else {
                gradient = ctx.createLinearGradient(node.x - 25, node.y - 25, node.x + 25, node.y + 25);
                gradient.addColorStop(0, '#667eea');
                gradient.addColorStop(1, '#764ba2');
            }

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(node.x, node.y, 25, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Draw value
            ctx.fillStyle = 'white';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(node.data, node.x, node.y);

            // Draw height and balance factor
            const balance = tree.getBalance(node);
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.fillText(`h:${node.h}`, node.x, node.y + 40);
            ctx.fillText(`b:${balance}`, node.x, node.y + 52);
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (tree.root) {
                calculatePositions(tree.root, canvas.width / 2, 50, 200);

                let allSettled = true;
                function updatePositions(node) {
                    if (!node) return;
                    if (!animateNode(node)) allSettled = false;
                    updatePositions(node.left);
                    updatePositions(node.right);
                }
                updatePositions(tree.root);

                drawTree(tree.root);

                if (allSettled && isAnimating) {
                    isAnimating = false;
                    function resetStates(node) {
                        if (!node) return;
                        node.state = 'normal';
                        resetStates(node.left);
                        resetStates(node.right);
                    }
                    resetStates(tree.root);
                }
            }

            requestAnimationFrame(animate);
        }

        async function insertValue() {
            const input = document.getElementById('valueInput');
            const value = parseInt(input.value);

            if (isNaN(value) || value < 1 || value > 999) {
                statusText.textContent = 'Please enter a valid number between 1 and 999';
                return;
            }

            isAnimating = true;
            const animations = tree.insertValue(value);

            for (let anim of animations) {
                if (anim.type === 'insert') {
                    statusText.textContent = `Inserted ${value}`;
                } else if (anim.type === 'rotate') {
                    anim.nodes.forEach(n => n.state = 'rotating');
                    statusText.textContent = `Performing ${anim.direction} rotation`;
                    await new Promise(resolve => setTimeout(resolve, 800));
                }
            }

            input.value = '';
        }

        function insertRandom() {
            const random = Math.floor(Math.random() * 100) + 1;
            document.getElementById('valueInput').value = random;
            insertValue();
        }

        function clearTree() {
            tree.root = null;
            isAnimating = false;
            statusText.textContent = 'Tree cleared. Enter a value to start building your AVL tree';
        }

        document.getElementById('valueInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') insertValue();
        });

        animate();
    </script>
</body>
</html>